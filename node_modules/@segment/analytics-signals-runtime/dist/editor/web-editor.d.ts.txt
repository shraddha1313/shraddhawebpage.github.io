/* eslint-disable */
// These types will be used in the segment app UI for autocomplete
// Generated from: @segment/analytics-signals-runtime@1.5.0
// Built as text so they do not cause global scope pollution for packages importing unrelated modules

declare interface BaseNavigationData<ActionType extends string> {
    action: ActionType;
    url: string;
    hash: string;
}

declare interface BaseNetworkData {
    action: string;
    url: string;
    data: JSONValue;
    contentType: string;
}

 declare interface BaseSignal {
    type: string;
    anonymousId: ID;
    timestamp: string;
}

/**
 * The base data that all web signal data must have
 */
 declare interface BaseWebData {
    page: PageData;
}

 declare type ChangeData = {
    eventType: 'change';
    /**
     * The target element that changed.
     */
    target: TargetedHTMLElement;
    /**
     * The name/type of "listener" that triggered the change.
     * Elements can change due to a variety of reasons, such as a mutation, a change event, or a contenteditable change
     */
    listener: 'contenteditable' | 'onchange' | 'mutation';
    /**
     * The change that occurred -- this is a key-value object of the change that occurred
     * For mutation listeners, this is the attributes that changed
     * For contenteditable listeners, this is the text that changed
     * @example
     * ```ts
     * { checked: true } // onchange
     * { value: 'new value' } // onchange / mutation
     * {'aria-selected': 'true' } // mutation
     * { textContent: 'Sentence1\nSentence2\n' } // contenteditable
     * ```
     */
    change: JSONValue;
};

declare type ClickData = {
    eventType: 'click';
    target: TargetedHTMLElement;
};

 declare const EventType: Readonly<{
    Track: "track";
    Page: "page";
    Screen: "screen";
    Identify: "identify";
    Group: "group";
    Alias: "alias";
}>;

 declare type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';

 declare type ID = string | null | undefined;

declare interface InstrumentationData {
    rawEvent: unknown;
}

 declare type InstrumentationSignal = RawSignal<'instrumentation', InstrumentationData>;

 declare type InteractionData = ClickData | SubmitData | ChangeData;

 declare type InteractionSignal = RawSignal<'interaction', InteractionData>;

 declare type JSONArray = JSONValue[];

 declare type JSONObject = {
    [member: string]: JSONValue;
};

 declare type JSONPrimitive = string | number | boolean | null;

 declare type JSONValue = JSONPrimitive | JSONObject | JSONArray;

 declare const NavigationAction: Readonly<{
    URLChange: "urlChange";
    PageLoad: "pageLoad";
}>;

 declare type NavigationData = URLChangeNavigationData | PageChangeNavigationData;

 declare type NavigationSignal = RawSignal<'navigation', NavigationData>;

 declare type NetworkData = NetworkRequestData | NetworkResponseData;

declare interface NetworkRequestData extends BaseNetworkData {
    action: 'request';
    url: string;
    method: HTTPMethod;
}

declare interface NetworkResponseData extends BaseNetworkData {
    action: 'response';
    url: string;
    status: number;
    ok: boolean;
}

 declare type NetworkSignal = RawSignal<'network', NetworkData>;

 declare interface NetworkSignalMetadata {
    filters: {
        allowed: string[];
        disallowed: string[];
    };
}

 declare interface PageChangeNavigationData extends BaseNavigationData<'pageLoad'> {
}

 declare interface PageData {
    /**
     * The full URL of the page
     * If there is a canonical URL, this should be the canonical URL
     * @example https://www.segment.com/docs/connections/sources/catalog/libraries/website/javascript/
     */
    url: string;
    /**
     * The path of the page
     * @example /docs/connections/sources/catalog/libraries/website/javascript/
     */
    path: string;
    /**
     * The search parameters of the page
     * @example ?utm_source=google
     */
    search: string;
    /**
     * The hostname of the page
     * @example www.segment.com
     */
    hostname: string;
    /**
     * The hash of the page
     * @example #hash
     */
    hash: string;
    /**
     * The referrer of the page
     * @example https://www.google.com/
     */
    referrer: string;
    /**
     * The title of the page
     * @example Segment - Documentation
     */
    title: string;
}

 declare type ParsedAttributes = {
    [attributeName: string]: string | null;
};

 declare interface RawSignal<T extends SignalTypes, Data> extends BaseSignal {
    type: T;
    data: BaseWebData & Data;
    metadata?: Record<string, any>;
}

 declare interface SegmentEvent {
    /**
     * @example 'track' | 'page' | 'screen' | 'identify' | 'group' | 'alias'
     */
    type: string;
    [key: string]: unknown;
}

 declare type Signal = InteractionSignal | NavigationSignal | InstrumentationSignal | NetworkSignal | UserDefinedSignal;

 declare type SignalOfType<AllSignals extends BaseSignal, SignalType extends AllSignals['type']> = AllSignals & {
    type: SignalType;
};

 declare const signals: WebSignalsRuntime;

/**
 * Base class that provides runtime utilities for signals.
 */
declare abstract class SignalsRuntime<Signal extends BaseSignal = BaseSignal> {
    signalBuffer: Signal[];
    constructor(signals?: Signal[]);
    /**
     * Finds a signal of a specific type from a given signal.
     *
     * SignalType - The type of the signal to find.
     * @param fromSignal - The signal to search from.
     * @param signalType - The type of the signal to find.
     * @param predicate - Optional predicate function to filter the signals.
     * @returns The found signal of the specified type, or undefined if not found.
     */
    find: <SignalType extends Signal["type"]>(fromSignal: Signal, signalType: SignalType, predicate?: ((signal: SignalOfType<Signal, SignalType>) => boolean) | undefined) => SignalOfType<Signal, SignalType> | undefined;
    /**
     * Filters signals of a specific type from a given signal.
     * SignalType - The type of the signals to filter.
     * @param fromSignal - The signal to search from.
     * @param signalType - The type of the signals to filter.
     * @param predicate - Optional predicate function to filter the signals.
     * @returns An array of signals of the specified type.
     */
    filter: <SignalType extends Signal["type"]>(fromSignal: Signal, signalType: SignalType, predicate?: ((signal: SignalOfType<Signal, SignalType>) => boolean) | undefined) => SignalOfType<Signal, SignalType>[];
}

 declare const SignalType: Readonly<{
    Interaction: "interaction";
    Navigation: "navigation";
    Network: "network";
    LocalData: "localData";
    Instrumentation: "instrumentation";
    UserDefined: "userDefined";
}>;

 declare type SignalTypes = Signal['type'];

declare type SubmitData = {
    eventType: 'submit';
    submitter?: TargetedHTMLElement;
    target: TargetedHTMLElement;
};

 declare interface TargetedHTMLElement {
    id: string;
    attributes: ParsedAttributes;
    [key: string]: any;
}

 declare interface URLChangeNavigationData extends BaseNavigationData<'urlChange'> {
    prevUrl: string;
}

 declare type UserDefinedSignal = RawSignal<'userDefined', UserDefinedSignalData>;

 declare interface UserDefinedSignalData {
    [key: string]: any;
}

 declare class WebSignalsRuntime extends SignalsRuntime<Signal> {
}

