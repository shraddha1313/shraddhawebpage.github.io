type AttributeMutations = {
    [attributeName: string]: string | null;
};
export type AttributeChangedEvent = {
    element: HTMLElement;
    attributes: AttributeMutations;
};
export interface MutationObservableSettingsConfig {
    extraSelectors?: string[];
    pollIntervalMs?: number;
    debounceMs?: number;
    emitInputStrategy?: 'debounce-only' | 'blur';
    observedRoles?: (defaultObservedRoles: string[]) => string[];
    observedTags?: (defaultObservedTags: string[]) => string[];
    observedAttributes?: (defaultObservedAttributes: string[]) => string[];
}
export declare class MutationObservableSettings {
    pollIntervalMs: number;
    debounceMs: number;
    emitInputStrategy: 'debounce-only' | 'blur';
    extraSelectors: string[];
    observedRoles: string[];
    observedTags: string[];
    observedAttributes: string[];
    constructor(config?: MutationObservableSettingsConfig);
}
export type MutationObservableSubscriber = (event: AttributeChangedEvent) => void;
/**
 * This class is responsible for observing changes to elements in the DOM
 * This is preferred over monitoring document 'change' events, as it captures changes to custom elements
 */
export declare class MutationObservable {
    private settings;
    private observedElements;
    private prevMutationsCache;
    private emitter;
    private listeners;
    subscribe(fn: MutationObservableSubscriber): void;
    cleanup(): void;
    private pollTimeout;
    constructor(settings?: MutationObservableSettings);
    private shouldEmitEvent;
    private experimentalOnChangeAdapter;
    private observeElementAttributes;
    private checkForNewElements;
}
export {};
//# sourceMappingURL=mutation-observer.d.ts.map