"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sandbox = exports.SandboxSettings = void 0;
const logger_1 = require("../../lib/logger");
const workerbox_1 = require("../../lib/workerbox");
const arg_resolvers_1 = require("./arg-resolvers");
const replace_base_url_1 = require("../../lib/replace-base-url");
const analytics_signals_runtime_1 = require("@segment/analytics-signals-runtime");
const polyfills_1 = require("./polyfills");
/**
 * Proxy around the analytics client
 */
class AnalyticsRuntime {
    constructor() {
        this.calls = {
            page: [],
            identify: [],
            track: [],
            alias: [],
            screen: [],
            group: [],
            reset: [],
        };
        // these methods need to be bound to the instance, rather than the prototype, in order to serialize correctly in the sandbox.
        this.track = (...args) => {
            try {
                // @ts-ignore
                const [eventName, props, options, cb] = arg_resolvers_1.resolvers.resolveArguments(
                // @ts-ignore
                ...args);
                this.calls.track.push([eventName, props, this.stamp(options), cb]);
            }
            catch (err) {
                // wrapping all methods in a try/catch because throwing an error won't cause the error to surface inside of workerboxjs
                console.error(err);
            }
        };
        this.identify = (...args) => {
            try {
                // @ts-ignore
                const [id, traits, options, cb] = arg_resolvers_1.resolvers.resolveUserArguments(...args);
                this.calls.identify.push([id, traits, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.alias = (...args) => {
            try {
                const [userId, previousId, options, cb] = arg_resolvers_1.resolvers.resolveAliasArguments(
                // @ts-ignore
                ...args);
                this.calls.alias.push([userId, previousId, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.group = (...args) => {
            try {
                // @ts-ignore
                const [id, traits, options, cb] = arg_resolvers_1.resolvers.resolveUserArguments(...args);
                this.calls.group.push([id, traits, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.page = (...args) => {
            try {
                const [category, name, props, options, cb] = arg_resolvers_1.resolvers.resolvePageArguments(...args);
                this.stamp(options);
                this.calls.page.push([category, name, props, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.screen = (...args) => {
            try {
                const [category, name, props, options, cb] = arg_resolvers_1.resolvers.resolvePageArguments(...args);
                this.stamp(options);
                this.calls.screen.push([category, name, props, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.reset = () => {
            this.calls.reset.push([]);
        };
    }
    getCalls() {
        return this.calls;
    }
    /**
     * Stamp the context with the event origin to prevent infinite signal-event loops.
     */
    stamp(options) {
        if (!options) {
            options = {};
        }
        options.context = { ...options.context, __eventOrigin: { type: 'Signal' } };
        return options;
    }
}
class JavascriptSandbox {
    constructor() {
        this.workerbox = (0, workerbox_1.createWorkerBox)();
    }
    async run(fn, scope) {
        try {
            const wb = await this.workerbox;
            await wb.run(fn, scope);
        }
        catch (err) {
            console.error('processSignal() error in sandbox', err, {
                fn,
            });
        }
    }
    async destroy() {
        const wb = await this.workerbox;
        await wb.destroy();
    }
}
class SandboxSettings {
    constructor(settings) {
        const edgeFnDownloadURLNormalized = settings.functionHost && settings.edgeFnDownloadURL
            ? (0, replace_base_url_1.replaceBaseUrl)(settings.edgeFnDownloadURL, `https://${settings.functionHost}`)
            : settings.edgeFnDownloadURL;
        if (!edgeFnDownloadURLNormalized && !settings.processSignal) {
            // user may be onboarding and not have written a signal -- so do a noop so we can collect signals
            this.processSignal = Promise.resolve(`globalThis.processSignal = function processSignal() {}`);
            console.warn(`No processSignal function found. Have you written a processSignal function on app.segment.com?`);
            return;
        }
        const fetch = settings.edgeFnFetchClient ?? globalThis.fetch;
        const processSignalNormalized = settings.processSignal
            ? Promise.resolve(settings.processSignal).then((str) => `globalThis.processSignal = ${str}`)
            : fetch(edgeFnDownloadURLNormalized).then((res) => res.text());
        this.processSignal = processSignalNormalized;
    }
}
exports.SandboxSettings = SandboxSettings;
class Sandbox {
    constructor(settings) {
        this.settings = settings;
        this.jsSandbox = new JavascriptSandbox();
    }
    async process(signal, signals) {
        const analytics = new AnalyticsRuntime();
        const scope = {
            analytics,
        };
        logger_1.logger.debug('processing signal', { signal, scope, signals });
        const code = [
            polyfills_1.polyfills,
            await this.settings.processSignal,
            (0, analytics_signals_runtime_1.getRuntimeCode)(),
            `signals.signalBuffer = ${JSON.stringify(signals)};`,
            'try { processSignal(' +
                JSON.stringify(signal) +
                ', { analytics, signals, SignalType, EventType, NavigationAction }); } catch(err) { console.error("Process signal failed.", err); }',
        ].join('\n');
        await this.jsSandbox.run(code, scope);
        const calls = analytics.getCalls();
        return calls;
    }
}
exports.Sandbox = Sandbox;
//# sourceMappingURL=sandbox.js.map