"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkGenerator = void 0;
const logger_1 = require("../../../lib/logger");
const factories_1 = require("../../../types/factories");
const network_interceptor_1 = require("./network-interceptor");
const helpers_1 = require("./helpers");
class NetworkGenerator {
    constructor() {
        this.id = 'network';
        this.interceptor = new network_interceptor_1.NetworkInterceptor();
        /* List of all signal request IDs that have been emitted */
        this.emittedRequestIds = [];
    }
    register(emitter) {
        const handleRequest = (rq) => {
            if (!rq.url) {
                return;
            }
            const data = typeof rq.body === 'string' ? (0, helpers_1.tryJSONParse)(rq.body) : null;
            this.emittedRequestIds.push(rq.id);
            emitter.emit((0, factories_1.createNetworkSignal)({
                action: 'request',
                url: rq.url,
                method: rq.method || 'GET',
                data,
                contentType: rq.headers?.get('content-type') || '',
            }));
        };
        const handleResponse = async (rs) => {
            const isSuccessWithNonJSONResponse = rs.ok &&
                rs.responseType !== 'json' &&
                !(0, helpers_1.containsJSONContentType)(rs.headers);
            const isErrorButRequestNeverEmittted = !rs.ok && !this.emittedRequestIds.includes(rs.req.id);
            if (isSuccessWithNonJSONResponse || isErrorButRequestNeverEmittted) {
                return;
            }
            const url = rs.url;
            if (!url) {
                return;
            }
            const data = await rs.body();
            emitter.emit((0, factories_1.createNetworkSignal)({
                action: 'response',
                url,
                data: data,
                ok: rs.ok,
                status: rs.status,
                contentType: rs.headers.get('content-type') || '',
            }));
        };
        this.interceptor.addInterceptors(handleRequest, handleResponse);
        return () => {
            this.interceptor.cleanup();
            logger_1.logger.debug('Removing fetch interceptor');
        };
    }
}
exports.NetworkGenerator = NetworkGenerator;
//# sourceMappingURL=index.js.map