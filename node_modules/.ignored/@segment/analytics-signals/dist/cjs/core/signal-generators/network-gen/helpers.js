"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRequestId = exports.normalizeRequestInfo = exports.tryJSONParse = exports.isOk = exports.containsJSONParseableContentType = exports.containsJSONContentType = exports.containsContentType = exports.normalizeHeaders = exports.isSameDomain = exports.getDomainFromHost = void 0;
/**
 * @example example.foo.bar.com => example.com
 * @example example.foo.co.uk => example.co.uk
 */
const getDomainFromHost = (hostName) => {
    const modified = hostName.replace('www.', '');
    const parts = modified.split('.');
    let offset = 2;
    if (
    // handle .co.uk, .com.au, .org.uk, .eu.com etc
    // this is a naive approach, but it's good enough for our use case
    ['co', 'com', 'org', 'eu'].includes(parts[parts.length - 2])) {
        offset = 3;
    }
    return parts.slice(-offset).join('.');
};
exports.getDomainFromHost = getDomainFromHost;
const isSameDomain = (url) => {
    // Relative URL like /foo/bar will always be considered same domain
    const rIsAbs = new RegExp('^(?:[a-z+]+:)?//', 'i');
    if (!rIsAbs.test(url)) {
        return true;
    }
    const host = new URL(url).hostname;
    return (0, exports.getDomainFromHost)(host) === (0, exports.getDomainFromHost)(window.location.hostname);
};
exports.isSameDomain = isSameDomain;
const normalizeHeaders = (headers) => {
    return headers instanceof Headers ? headers : new Headers(headers);
};
exports.normalizeHeaders = normalizeHeaders;
/**
 * @example expect(containsContentType(headers, ['application/json'])).toBe(true)
 */
const containsContentType = (headers, match) => {
    if (!headers) {
        return false;
    }
    const normalizedHeaders = (0, exports.normalizeHeaders)(headers);
    return match.some((t) => normalizedHeaders.get('content-type')?.includes(t));
};
exports.containsContentType = containsContentType;
const containsJSONContentType = (Headers) => {
    return (0, exports.containsContentType)(Headers, [
        'application/json',
        'application/ld+json',
        'text/json',
    ]);
};
exports.containsJSONContentType = containsJSONContentType;
const containsJSONParseableContentType = (headers) => {
    return ((0, exports.containsJSONContentType)(headers) ||
        (0, exports.containsContentType)(headers, ['text/plain']));
};
exports.containsJSONParseableContentType = containsJSONParseableContentType;
const isOk = (status) => status >= 200 && status < 300;
exports.isOk = isOk;
/**
 * Safely parse JSON, if it fails, return the original text.
 */
const tryJSONParse = (text) => {
    try {
        return JSON.parse(text);
    }
    catch (err) {
        return text;
    }
};
exports.tryJSONParse = tryJSONParse;
/**
 * Normalize the first parameter of a fetch request
 */
const normalizeRequestInfo = (requestInfo) => {
    if (typeof requestInfo === 'string') {
        return requestInfo;
    }
    else if ('url' in requestInfo) {
        return requestInfo.url;
    }
    else {
        return requestInfo.toString();
    }
};
exports.normalizeRequestInfo = normalizeRequestInfo;
const createRequestId = () => {
    return Math.random().toString(36).substring(3);
};
exports.createRequestId = createRequestId;
//# sourceMappingURL=helpers.js.map