"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signals = void 0;
const buffer_1 = require("../buffer");
const emitter_1 = require("../emitter");
const dom_gen_1 = require("../signal-generators/dom-gen");
const network_gen_1 = require("../signal-generators/network-gen");
const register_1 = require("../signal-generators/register");
const analytics_service_1 = require("../analytics-service");
const settings_1 = require("./settings");
const logger_1 = require("../../lib/logger");
const signals_ingest_1 = require("../middleware/signals-ingest");
const event_processor_1 = require("../middleware/event-processor");
const network_signals_filter_1 = require("../middleware/network-signals-filter/network-signals-filter");
const user_info_1 = require("../middleware/user-info");
class Signals {
    constructor(settingsConfig = {}) {
        this.cleanup = [];
        this.globalSettings = new settings_1.SignalGlobalSettings(settingsConfig);
        if (settingsConfig.debug) {
            this.debug();
        }
        this.buffer = (0, buffer_1.getSignalBuffer)(this.globalSettings.signalBuffer);
        this.signalEmitter = this.getSignalEmitter(settingsConfig.middleware);
        // We register the generators (along with the signal emitter) so they start collecting signals before the plugin is started.
        // Otherwise, we would wait until analytics is loaded, which would skip things like page network URL changes.
        void this.registerGenerator([...dom_gen_1.domGenerators, new network_gen_1.NetworkGenerator()]);
    }
    /**
     * Does the following:
     * - Sends any queued signals to the server.
     * - Registers additional custom signal generators.
     */
    async start(analytics) {
        const analyticsService = new analytics_service_1.AnalyticsService(analytics);
        analyticsService.instance.on('reset', () => {
            this.clearStorage();
        });
        // These settings are important to middleware configuration (e.g, they drop events)
        // The middleware doesn't run until the signalEmitter is initialized -- so we need to set these settings before starting the emitter
        this.globalSettings.update({
            edgeFnDownloadURL: analyticsService.edgeFnSettings?.downloadURL,
            disallowListURLs: [
                analyticsService.instance.settings.apiHost,
                analyticsService.instance.settings.cdnURL,
            ],
            sampleRate: analyticsService.instance.settings.cdnSettings
                .autoInstrumentationSettings?.sampleRate ?? 0,
        });
        await this.registerGenerator([
            analyticsService.createSegmentInstrumentationEventGenerator(),
        ]);
        // load emitter and flush any queued signals to all subscribers. Register middleware
        void this.signalEmitter.start({
            unstableGlobalSettings: this.globalSettings,
            analyticsInstance: analyticsService.instance,
            buffer: this.buffer,
        });
    }
    stop() {
        this.cleanup.forEach((fn) => fn());
    }
    clearStorage() {
        void this.buffer.clear();
    }
    /**
     * Disable redaction, ingestion of signals, and other logging.
     */
    debug(boolean = true, logLevel) {
        this.globalSettings.signalsDebug.setAllDebugging(boolean);
        logger_1.logger.enableLogging(logLevel ?? 'info');
    }
    /**
     * Register custom signal generators to emit signals.
     */
    async registerGenerator(generators) {
        if (!this.signalEmitter) {
            throw new Error('SignalEmitter not initialized');
        }
        if (!this.globalSettings) {
            throw new Error('GlobalSettings not initialized');
        }
        this.cleanup.push(await (0, register_1.registerGenerator)(this.signalEmitter, generators, this.globalSettings));
    }
    getSignalEmitter(middleware) {
        // we initialize the emitter here so that registerGenerator can be called before start
        return new emitter_1.SignalEmitter()
            .addMiddleware(new user_info_1.UserInfoMiddleware(), new network_signals_filter_1.NetworkSignalsFilterMiddleware(), ...(middleware || []))
            .subscribe((signal) => logger_1.logger.logSignal(signal), (signal) => this.buffer.add(signal), new signals_ingest_1.SignalsIngestSubscriber(), new event_processor_1.SignalsEventProcessorSubscriber());
    }
}
exports.Signals = Signals;
//# sourceMappingURL=signals.js.map