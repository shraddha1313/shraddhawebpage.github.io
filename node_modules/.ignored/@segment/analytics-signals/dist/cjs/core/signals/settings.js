"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalsDebugSettings = exports.SignalGlobalSettings = void 0;
const debug_mode_1 = require("../debug-mode");
const logger_1 = require("../../lib/logger");
const web_storage_1 = require("../../lib/storage/web-storage");
const change_gen_1 = require("../signal-generators/dom-gen/change-gen");
const network_signals_filter_1 = require("../middleware/network-signals-filter/network-signals-filter");
/**
 * Global settings for the application
 * In the future this pattern may allows us to add settings which can be dynamically set by the user.
 * Currently, this is just a way to pass settings to the different parts of the application.
 */
class SignalGlobalSettings {
    constructor(settings) {
        this.sampleSuccess = false;
        if (settings.maxBufferSize && settings.signalStorage) {
            throw new Error('maxBufferSize and signalStorage cannot be defined at the same time');
        }
        this.mutationGenerator = new change_gen_1.MutationGeneratorSettings({
            extraSelectors: settings.mutationGenExtraSelectors,
            observedRoles: settings.mutationGenObservedRoles,
            observedTags: settings.mutationGenObservedTags,
            pollIntervalMs: settings.mutationGenPollInterval,
            observedAttributes: settings.mutationGenObservedAttributes,
        });
        this.signalsDebug = new SignalsDebugSettings(settings.disableSignalsRedaction, settings.enableSignalsIngestion);
        this.signalBuffer = {
            signalStorage: settings.signalStorage,
            storageType: settings.signalStorageType,
            maxBufferSize: settings.maxBufferSize,
        };
        this.ingestClient = {
            apiHost: settings.apiHost,
            flushAt: settings.flushAt,
            flushInterval: settings.flushInterval,
            shouldDisableSignalsRedaction: this.signalsDebug.getDisableSignalsRedaction,
            shouldIngestSignals: () => {
                if (this.signalsDebug.getEnableSignalsIngestion()) {
                    return true;
                }
                if (this.sampleSuccess) {
                    return true;
                }
                return false;
            },
        };
        this.sandbox = {
            functionHost: settings.functionHost,
            processSignal: settings.processSignal,
            edgeFnDownloadURL: undefined,
        };
        this.network = new network_signals_filter_1.NetworkSettingsConfig({
            networkSignalsAllowList: settings.networkSignalsAllowList,
            networkSignalsDisallowList: settings.networkSignalsDisallowList,
            networkSignalsAllowSameDomain: settings.networkSignalsAllowSameDomain,
        });
    }
    update({ edgeFnDownloadURL, disallowListURLs, sampleRate, }) {
        edgeFnDownloadURL && (this.sandbox.edgeFnDownloadURL = edgeFnDownloadURL);
        this.network.networkSignalsFilterList.disallowed.addURLLike(...disallowListURLs.filter((val) => Boolean(val)));
        this.sampleSuccess = this.checkSampleRate(sampleRate ?? 0);
    }
    checkSampleRate(sampleRate) {
        const storage = new web_storage_1.WebStorage(window.sessionStorage);
        const previousSample = storage.getItem('segment_sample_success');
        if (previousSample !== undefined) {
            return previousSample;
        }
        if (sampleRate && Math.random() <= sampleRate) {
            storage.setItem('segment_sample_success', true);
            return true;
        }
        storage.setItem('segment_sample_success', false);
        return false;
    }
}
exports.SignalGlobalSettings = SignalGlobalSettings;
class SignalsDebugSettings {
    constructor(disableRedaction, enableIngestion) {
        this.storage = new web_storage_1.WebStorage(window.sessionStorage);
        this.setAllDebugging = (boolean) => {
            this.storage.setItem(SignalsDebugSettings.redactionKey, boolean);
            this.storage.setItem(SignalsDebugSettings.ingestionKey, boolean);
        };
        this.getDisableSignalsRedaction = () => {
            return (this.storage.getItem(SignalsDebugSettings.redactionKey) ?? false);
        };
        this.getEnableSignalsIngestion = () => {
            return (this.storage.getItem(SignalsDebugSettings.ingestionKey) ?? false);
        };
        if (typeof disableRedaction === 'boolean') {
            this.storage.setItem(SignalsDebugSettings.redactionKey, disableRedaction);
        }
        if (typeof enableIngestion === 'boolean') {
            this.storage.setItem(SignalsDebugSettings.ingestionKey, enableIngestion);
        }
        const debugModeInQs = (0, debug_mode_1.parseDebugModeQueryString)();
        logger_1.logger.debug('debugMode is set to true via query string');
        if (typeof debugModeInQs === 'boolean') {
            this.setAllDebugging(debugModeInQs);
        }
    }
}
exports.SignalsDebugSettings = SignalsDebugSettings;
SignalsDebugSettings.redactionKey = 'segment_signals_debug_redaction_disabled';
SignalsDebugSettings.ingestionKey = 'segment_signals_debug_ingestion_enabled';
//# sourceMappingURL=settings.js.map