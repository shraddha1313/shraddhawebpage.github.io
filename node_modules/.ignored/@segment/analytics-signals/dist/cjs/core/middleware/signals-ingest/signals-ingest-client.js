"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalsIngestClient = exports.SignalsIngestSettings = void 0;
const analytics_next_1 = require("@segment/analytics-next");
const logger_1 = require("../../../lib/logger");
const redact_1 = require("./redact");
class SignalsIngestSettings {
    constructor(settings) {
        this.flushAt = settings.flushAt ?? 5;
        this.apiHost = settings.apiHost ?? 'signals.segment.io/v1';
        this.flushInterval = settings.flushInterval ?? 2000;
        this.shouldDisableSignalsRedaction =
            settings.shouldDisableSignalsRedaction ?? (() => false);
        this.shouldIngestSignals = settings.shouldIngestSignals ?? (() => false);
    }
}
exports.SignalsIngestSettings = SignalsIngestSettings;
/**
 * This currently just uses the Segment analytics-next library to send signals.
 * This persists the signals in a queue until the client is initialized.
 */
class SignalsIngestClient {
    constructor(writeKey, settings = {}) {
        /**
         * This matters to sort the signals in the UI if the timestamp conflict (which can happen very very rarely)
         */
        this.index = 0;
        this.settings = new SignalsIngestSettings(settings);
        this.analytics = this.createAnalyticsClient({ writeKey });
    }
    async createAnalyticsClient(settings) {
        const analytics = new analytics_next_1.Analytics({ writeKey: settings.writeKey });
        this.settings.writeKey = analytics.settings.writeKey;
        await analytics.register((0, analytics_next_1.segmentio)(analytics, {
            apiHost: this.settings.apiHost,
            apiKey: this.settings.writeKey,
            deliveryStrategy: {
                config: {
                    size: this.settings.flushAt,
                    timeout: this.settings.flushInterval,
                },
                strategy: 'batching',
            },
        }));
        analytics.emit('initialize', settings);
        analytics.on('track', (...args) => {
            logger_1.logger.debug('Track event from analytics client', ...args);
        });
        return analytics;
    }
    async sendTrackCall(signal) {
        const analytics = await this.analytics;
        if (!this.settings.shouldIngestSignals()) {
            return;
        }
        const disableRedaction = this.settings.shouldDisableSignalsRedaction();
        const cleanSignal = disableRedaction ? signal : (0, redact_1.redactSignalData)(signal);
        if (disableRedaction) {
            logger_1.logger.debug('Sending unredacted data to segment', cleanSignal);
        }
        const MAGIC_EVENT_NAME = 'Segment Signal Generated';
        return analytics.track(MAGIC_EVENT_NAME, {
            index: this.index++,
            ...cleanSignal,
        });
    }
    send(signal) {
        return this.sendTrackCall(signal);
    }
}
exports.SignalsIngestClient = SignalsIngestClient;
//# sourceMappingURL=signals-ingest-client.js.map