import { logger } from '../../lib/logger';
import { createWorkerBox } from '../../lib/workerbox';
import { resolvers } from './arg-resolvers';
import { replaceBaseUrl } from '../../lib/replace-base-url';
import { getRuntimeCode } from '@segment/analytics-signals-runtime';
import { polyfills } from './polyfills';
/**
 * Proxy around the analytics client
 */
class AnalyticsRuntime {
    constructor() {
        this.calls = {
            page: [],
            identify: [],
            track: [],
            alias: [],
            screen: [],
            group: [],
            reset: [],
        };
        // these methods need to be bound to the instance, rather than the prototype, in order to serialize correctly in the sandbox.
        this.track = (...args) => {
            try {
                // @ts-ignore
                const [eventName, props, options, cb] = resolvers.resolveArguments(
                // @ts-ignore
                ...args);
                this.calls.track.push([eventName, props, this.stamp(options), cb]);
            }
            catch (err) {
                // wrapping all methods in a try/catch because throwing an error won't cause the error to surface inside of workerboxjs
                console.error(err);
            }
        };
        this.identify = (...args) => {
            try {
                // @ts-ignore
                const [id, traits, options, cb] = resolvers.resolveUserArguments(...args);
                this.calls.identify.push([id, traits, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.alias = (...args) => {
            try {
                const [userId, previousId, options, cb] = resolvers.resolveAliasArguments(
                // @ts-ignore
                ...args);
                this.calls.alias.push([userId, previousId, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.group = (...args) => {
            try {
                // @ts-ignore
                const [id, traits, options, cb] = resolvers.resolveUserArguments(...args);
                this.calls.group.push([id, traits, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.page = (...args) => {
            try {
                const [category, name, props, options, cb] = resolvers.resolvePageArguments(...args);
                this.stamp(options);
                this.calls.page.push([category, name, props, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.screen = (...args) => {
            try {
                const [category, name, props, options, cb] = resolvers.resolvePageArguments(...args);
                this.stamp(options);
                this.calls.screen.push([category, name, props, this.stamp(options), cb]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.reset = () => {
            this.calls.reset.push([]);
        };
    }
    getCalls() {
        return this.calls;
    }
    /**
     * Stamp the context with the event origin to prevent infinite signal-event loops.
     */
    stamp(options) {
        if (!options) {
            options = {};
        }
        options.context = { ...options.context, __eventOrigin: { type: 'Signal' } };
        return options;
    }
}
class JavascriptSandbox {
    constructor() {
        this.workerbox = createWorkerBox();
    }
    async run(fn, scope) {
        try {
            const wb = await this.workerbox;
            await wb.run(fn, scope);
        }
        catch (err) {
            console.error('processSignal() error in sandbox', err, {
                fn,
            });
        }
    }
    async destroy() {
        const wb = await this.workerbox;
        await wb.destroy();
    }
}
export class SandboxSettings {
    constructor(settings) {
        const edgeFnDownloadURLNormalized = settings.functionHost && settings.edgeFnDownloadURL
            ? replaceBaseUrl(settings.edgeFnDownloadURL, `https://${settings.functionHost}`)
            : settings.edgeFnDownloadURL;
        if (!edgeFnDownloadURLNormalized && !settings.processSignal) {
            // user may be onboarding and not have written a signal -- so do a noop so we can collect signals
            this.processSignal = Promise.resolve(`globalThis.processSignal = function processSignal() {}`);
            console.warn(`No processSignal function found. Have you written a processSignal function on app.segment.com?`);
            return;
        }
        const fetch = settings.edgeFnFetchClient ?? globalThis.fetch;
        const processSignalNormalized = settings.processSignal
            ? Promise.resolve(settings.processSignal).then((str) => `globalThis.processSignal = ${str}`)
            : fetch(edgeFnDownloadURLNormalized).then((res) => res.text());
        this.processSignal = processSignalNormalized;
    }
}
export class Sandbox {
    constructor(settings) {
        this.settings = settings;
        this.jsSandbox = new JavascriptSandbox();
    }
    async process(signal, signals) {
        const analytics = new AnalyticsRuntime();
        const scope = {
            analytics,
        };
        logger.debug('processing signal', { signal, scope, signals });
        const code = [
            polyfills,
            await this.settings.processSignal,
            getRuntimeCode(),
            `signals.signalBuffer = ${JSON.stringify(signals)};`,
            'try { processSignal(' +
                JSON.stringify(signal) +
                ', { analytics, signals, SignalType, EventType, NavigationAction }); } catch(err) { console.error("Process signal failed.", err); }',
        ].join('\n');
        await this.jsSandbox.run(code, scope);
        const calls = analytics.getCalls();
        return calls;
    }
}
//# sourceMappingURL=sandbox.js.map