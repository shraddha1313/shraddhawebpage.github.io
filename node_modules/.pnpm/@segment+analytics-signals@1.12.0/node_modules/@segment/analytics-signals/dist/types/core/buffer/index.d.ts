import { Signal } from '@segment/analytics-signals-runtime';
import { DBSchema, IDBPDatabase, IDBPObjectStore } from 'idb';
interface SignalDatabase extends DBSchema {
    signals: {
        key: string;
        value: Signal;
    };
}
export interface SignalPersistentStorage {
    getAll(): Promise<Signal[]> | Signal[];
    add(value: Signal): Promise<void> | void;
    clear(): void;
}
interface IDBPDatabaseSignals extends IDBPDatabase<SignalDatabase> {
}
interface IDBPObjectStoreSignals extends IDBPObjectStore<SignalDatabase, [
    'signals'
], 'signals', 'readonly' | 'readwrite' | 'versionchange'> {
}
interface StoreSettings {
    maxBufferSize?: number;
}
export declare class SignalStoreIndexDB implements SignalPersistentStorage {
    static readonly DB_NAME = "Segment Signals Buffer";
    static readonly STORE_NAME = "signals";
    private db;
    private maxBufferSize;
    private sessionKeyStorage;
    static deleteDatabase(): IDBOpenDBRequest;
    getStore(permission: IDBTransactionMode, database?: IDBPDatabaseSignals): Promise<IDBPObjectStoreSignals>;
    constructor(settings: StoreSettings);
    private initSignalDB;
    private clearStoreIfNeeded;
    add(signal: Signal): Promise<void>;
    private countAndDeleteOldestIfNeeded;
    /**
     * Get list of signals from the store, with the newest signals first.
     */
    getAll(): Promise<Signal[]>;
    clear(): Promise<void>;
}
export declare class SignalStoreSessionStorage implements SignalPersistentStorage {
    private readonly storageKey;
    private maxBufferSize;
    constructor(settings: StoreSettings);
    add(signal: Signal): void;
    clear(): void;
    getAll(): Signal[];
}
export declare class SignalBuffer<T extends SignalPersistentStorage = SignalPersistentStorage> {
    store: T;
    constructor(store: T);
    add(signal: Signal): Promise<void>;
    getAll(): Promise<Signal[]>;
    clear(): Promise<void>;
}
export interface SignalBufferSettingsConfig<T extends SignalPersistentStorage = SignalPersistentStorage> {
    /**
     * Maximum number of signals to store. Only applies if no custom storage implementation is provided.
     */
    maxBufferSize?: number;
    /**
     * Choose between sessionStorage and indexDB. Only applies if no custom storage implementation is provided.
     * @default 'indexDB'
     */
    storageType?: 'session' | 'indexDB';
    /**
     * Custom storage implementation
     * @default SignalStoreIndexDB
     */
    signalStorage?: T;
}
export declare const getSignalBuffer: <T extends SignalPersistentStorage = SignalPersistentStorage>(settings: SignalBufferSettingsConfig<T>) => SignalBuffer<SignalStoreIndexDB | SignalStoreSessionStorage>;
export {};
//# sourceMappingURL=index.d.ts.map