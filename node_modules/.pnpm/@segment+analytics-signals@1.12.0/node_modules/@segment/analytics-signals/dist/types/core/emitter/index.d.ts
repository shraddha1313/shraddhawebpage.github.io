import { Signal } from '@segment/analytics-signals-runtime';
import { AnyAnalytics } from '../../types';
import { SignalBuffer } from '../buffer';
import { SignalGlobalSettings } from '../signals';
export interface EmitSignal {
    emit: (signal: Signal) => void;
}
export interface SignalsMiddlewareContext {
    /**
     * These are global application settings. They are considered unstable, and should only be used internally.
     * @interal
     */
    readonly unstableGlobalSettings: SignalGlobalSettings;
    /**
     * @internal
     */
    analyticsInstance: AnyAnalytics;
    /**
     * @internal
     */
    buffer: SignalBuffer;
}
export interface PluginSettings {
    writeKey: string;
}
/**
 * A middleware is a plugin that modifies or drops signals
 */
export interface SignalsMiddleware {
    /**
     * Wait for .load to complete before emitting signals
     * This blocks the signal emitter until all plugins are loaded.
     */
    load(ctx: SignalsMiddlewareContext): Promise<void> | void;
    process(signal: Signal): Signal | null;
}
/**
 * A subscriber is basically a destination -- it receives a signal once it has travelled through the pipeline.
 */
export interface SignalsSubscriber {
    /**
     * Wait for .load to complete before emitting signals to this subscriber
     */
    load(ctx: SignalsMiddlewareContext): Promise<void> | void;
    process(signal: Signal): void;
}
export type AnySignalSubscriber = SignalsSubscriber | ((signal: Signal) => void);
export interface SignalEmitterSettings {
    middleware?: SignalsMiddleware[];
}
export declare class SignalEmitter implements EmitSignal {
    private subscribers;
    private middlewares;
    private signalQueue;
    private startedCtx?;
    constructor(settings?: SignalEmitterSettings);
    /**
     * Load all middleware, flush the buffer, and enable eager processing
     */
    start(signalsMiddlewareContext: SignalsMiddlewareContext): Promise<this>;
    /**
     * Enqueue a signal to be processed by all plugins and subscribers
     */
    emit(signal: Signal): void;
    addMiddleware(...mws: SignalsMiddleware[]): this;
    removeMiddleware(...mws: SignalsMiddleware[]): this;
    /**
     * Listen to signals emitted, once they have travelled through the plugin pipeline.
     * This is equivalent to a destination plugin.
     */
    subscribe(...subs: AnySignalSubscriber[]): this;
    unsubscribe(...unsubbed: AnySignalSubscriber[]): this;
    private processAndEmit;
}
//# sourceMappingURL=index.d.ts.map