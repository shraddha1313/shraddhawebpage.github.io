import { Signal } from '@segment/analytics-signals-runtime';
export declare class SignalsIngestSettings {
    flushAt: number;
    flushInterval: number;
    apiHost: string;
    shouldDisableSignalsRedaction: () => boolean;
    shouldIngestSignals: () => boolean;
    writeKey?: string;
    constructor(settings: SignalsIngestSettingsConfig);
}
export interface SignalsIngestSettingsConfig {
    apiHost?: string;
    flushAt?: number;
    flushInterval?: number;
    shouldDisableSignalsRedaction?: () => boolean;
    shouldIngestSignals?: () => boolean;
}
/**
 * This currently just uses the Segment analytics-next library to send signals.
 * This persists the signals in a queue until the client is initialized.
 */
export declare class SignalsIngestClient {
    private settings;
    private analytics;
    /**
     * This matters to sort the signals in the UI if the timestamp conflict (which can happen very very rarely)
     */
    private index;
    constructor(writeKey: string, settings?: SignalsIngestSettingsConfig);
    private createAnalyticsClient;
    private sendTrackCall;
    send(signal: Signal): Promise<import("@segment/analytics-next").Context | undefined>;
}
//# sourceMappingURL=signals-ingest-client.d.ts.map