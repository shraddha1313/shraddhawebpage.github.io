"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutationObservable = exports.MutationObservableSettings = void 0;
const analytics_generic_utils_1 = require("@segment/analytics-generic-utils");
const exists_1 = require("../../../lib/exists");
const debounce_1 = require("../../../lib/debounce");
const logger_1 = require("../../../lib/logger");
const helpers_1 = require("./helpers");
const DEFAULT_OBSERVED_ATTRIBUTES = [
    'aria-pressed',
    'aria-checked',
    'aria-modal',
    'aria-selected',
    'value',
    'checked',
    'data-selected',
];
const DEFAULT_OBSERVED_TAGS = ['input', 'label', 'option', 'select', 'textarea'];
const DEFAULT_OBSERVED_ROLES = [
    'button',
    'checkbox',
    'dialog',
    'gridcell',
    'row',
    'searchbox',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'radio',
    'scrollbar',
    'slider',
    'spinbutton',
    'switch',
    'tab',
    'treeitem',
];
class MutationObservableSettings {
    constructor(config = {}) {
        const { pollIntervalMs = 400, debounceMs = 1000, emitInputStrategy = 'debounce-only', extraSelectors = [], observedRoles, observedTags, observedAttributes, } = config;
        if (pollIntervalMs < 300) {
            throw new Error('Poll interval must be at least 300ms');
        }
        this.emitInputStrategy = emitInputStrategy;
        this.pollIntervalMs = pollIntervalMs;
        this.debounceMs = debounceMs;
        this.extraSelectors = extraSelectors;
        this.observedRoles = observedRoles
            ? observedRoles(DEFAULT_OBSERVED_ROLES)
            : DEFAULT_OBSERVED_ROLES;
        this.observedTags = observedTags
            ? observedTags(DEFAULT_OBSERVED_TAGS)
            : DEFAULT_OBSERVED_TAGS;
        this.observedAttributes = observedAttributes
            ? observedAttributes(DEFAULT_OBSERVED_ATTRIBUTES)
            : DEFAULT_OBSERVED_ATTRIBUTES;
    }
}
exports.MutationObservableSettings = MutationObservableSettings;
const shouldDebounce = (el) => {
    const MUTABLE_INPUT_TYPES = new Set([
        'text',
        'password',
        'email',
        'url',
        'tel',
        'number',
        'search',
        'date',
        'time',
        'datetime-local',
        'month',
        'week',
        'color',
        'range',
        null, // same as 'text'
    ]);
    const ROLES = new Set(['spinbutton']);
    const isInput = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement;
    const isContentEditable = el.isContentEditable;
    if (isContentEditable) {
        return true;
    }
    if (!isInput) {
        return false;
    }
    const type = el.getAttribute('type');
    if (MUTABLE_INPUT_TYPES.has(type)) {
        return true;
    }
    const role = el.getAttribute('role');
    if (role && ROLES.has(role)) {
        return true;
    }
    return false;
};
/**
 * This class is responsible for observing changes to elements in the DOM
 * This is preferred over monitoring document 'change' events, as it captures changes to custom elements
 */
class MutationObservable {
    subscribe(fn) {
        this.listeners.add(fn);
        this.emitter.on('attributeChanged', fn);
    }
    cleanup() {
        this.listeners.forEach((fn) => this.emitter.off('attributeChanged', fn));
        this.listeners.clear();
        clearInterval(this.pollTimeout);
    }
    constructor(settings) {
        // Track observed elements to avoid duplicate observers
        // WeakSet is used here to allow garbage collection of elements that are no longer in the DOM
        this.observedElements = new WeakSet();
        this.prevMutationsCache = new WeakMap();
        this.emitter = new ElementChangedEmitter();
        this.listeners = new Set();
        this.experimentalOnChangeAdapter = new ExperimentalOnChangeEventAdapter();
        this.settings = settings ?? new MutationObservableSettings();
        this.checkForNewElements(this.emitter);
        this.pollTimeout = setInterval(() => this.checkForNewElements(this.emitter), this.settings.pollIntervalMs);
    }
    shouldEmitEvent(attributeName, newValue) {
        // Filter out aria-selected events where the new value is false, since there will always be another selected value -- otherwise, checked would/should be used
        if (attributeName === 'aria-selected' && newValue === 'false') {
            return false;
        }
        return true;
    }
    observeElementAttributes(element, attributes, emitter) {
        if (!(element instanceof HTMLElement)) {
            return;
        }
        const _emitAttributeMutationEvent = (attributes) => {
            emitter.emit('attributeChanged', {
                element,
                attributes,
            });
        };
        const addOnBlurListener = (attributeMutations) => this.experimentalOnChangeAdapter.onBlur(element, () => _emitAttributeMutationEvent(attributeMutations));
        const emit = this.settings.emitInputStrategy === 'blur'
            ? addOnBlurListener
            : _emitAttributeMutationEvent;
        const shouldDebounceElement = shouldDebounce(element);
        const _emitMaybeDebouncedEvent = shouldDebounceElement
            ? (0, debounce_1.debounceWithKey)(emit, 
            // debounce based on the attribute names, so that we can debounce all changes to a single attribute. e.g if attribute "value" changes, that gets debounced, but if another attribute changes, that gets debounced separately
            (m) => Object.keys(m).sort(), this.settings.debounceMs)
            : _emitAttributeMutationEvent;
        // any call to setAttribute triggers a mutation event
        const cb = (mutationsList) => {
            const mutations = mutationsList
                .filter((m) => m.type === 'attributes')
                .map((m) => {
                const attributeName = m.attributeName;
                const target = m.target;
                if (!attributeName || !target || !(target instanceof HTMLElement))
                    return;
                const newValue = target.getAttribute(attributeName);
                const v = {
                    attributeName,
                    newValue: newValue,
                };
                logger_1.logger.debug('Attribute mutation', {
                    newValue,
                    oldValue: m.oldValue,
                    target: m.target,
                });
                return v;
            })
                .filter(exists_1.exists)
                .filter((event) => this.shouldEmitEvent(event.attributeName, event.newValue))
                .reduce((acc, mut) => {
                acc[mut.attributeName] = mut.newValue;
                return acc;
            }, {});
            const isEmpty = Object.keys(mutations).length === 0;
            if (isEmpty) {
                return;
            }
            // only emit if there are actual change to an attribute.
            // in mutationObserver, setAttribute('value', ''), setAttribute('value', '') will both trigger a mutation event
            // if the value is the same as the last one emitted from a given element, we don't want to emit it again
            const prevMutations = this.prevMutationsCache.get(element);
            if (prevMutations) {
                const hasActuallyChanged = !(0, helpers_1.isObjectMatch)(mutations, prevMutations);
                if (!hasActuallyChanged) {
                    return;
                }
            }
            this.prevMutationsCache.set(element, {
                ...prevMutations,
                ...mutations,
            });
            _emitMaybeDebouncedEvent(mutations);
        };
        const observer = new MutationObserver(cb);
        observer.observe(element, {
            attributes: true,
            attributeFilter: attributes,
            subtree: false,
        });
        this.observedElements.add(element);
    }
    checkForNewElements(emitter) {
        const allElementSelectors = [
            ...this.settings.observedRoles.map((role) => `[role="${role}"]`),
            ...this.settings.observedTags,
            ...this.settings.extraSelectors,
        ];
        allElementSelectors.forEach((selector) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element) => {
                if (this.observedElements.has(element)) {
                    return;
                }
                logger_1.logger.debug('Observing element', element);
                this.observeElementAttributes(element, this.settings.observedAttributes, emitter);
            });
        });
    }
}
exports.MutationObservable = MutationObservable;
/**
 * This class is responsible for normalizing listener behavior so that events are only emitted once -- just like 'change' events
 */
class ExperimentalOnChangeEventAdapter {
    constructor() {
        this.inputListeners = new Map();
    }
    removeListener(element) {
        const oldListener = this.inputListeners.get(element);
        if (oldListener) {
            element.removeEventListener('blur', oldListener);
        }
    }
    onBlur(element, cb) {
        this.removeListener(element);
        element.addEventListener('blur', cb, { once: true }); // once: true is important here, otherwise we'd get duplicate events if someone clicks out of the input and then back in
        // on 'enter' keydown, we also want to emit the event
        element.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                cb();
            }
        }, { once: true });
        this.inputListeners.set(element, cb);
    }
}
class ElementChangedEmitter extends analytics_generic_utils_1.Emitter {
}
//# sourceMappingURL=mutation-observer.js.map