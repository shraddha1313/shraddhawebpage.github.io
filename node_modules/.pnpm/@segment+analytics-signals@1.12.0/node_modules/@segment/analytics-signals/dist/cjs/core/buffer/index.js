"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignalBuffer = exports.SignalBuffer = exports.SignalStoreSessionStorage = exports.SignalStoreIndexDB = void 0;
const idb_1 = require("idb");
const logger_1 = require("../../lib/logger");
const web_storage_1 = require("../../lib/storage/web-storage");
const MAX_BUFFER_SIZE_DEFAULT = 50;
class SignalStoreIndexDB {
    static deleteDatabase() {
        return indexedDB.deleteDatabase(SignalStoreIndexDB.DB_NAME);
    }
    async getStore(permission, database) {
        const db = database ?? (await this.db);
        const store = db
            .transaction(SignalStoreIndexDB.STORE_NAME, permission)
            .objectStore(SignalStoreIndexDB.STORE_NAME);
        return store;
    }
    constructor(settings) {
        this.sessionKeyStorage = new web_storage_1.WebStorage(window.sessionStorage);
        this.maxBufferSize = settings.maxBufferSize ?? MAX_BUFFER_SIZE_DEFAULT;
        this.db = this.initSignalDB();
    }
    async initSignalDB() {
        const db = await (0, idb_1.openDB)(SignalStoreIndexDB.DB_NAME, 1, {
            upgrade(db) {
                db.createObjectStore(SignalStoreIndexDB.STORE_NAME, {
                    autoIncrement: true,
                });
            },
        });
        logger_1.logger.debug('Signals Buffer (indexDB) initialized');
        // if the signal buffer is too large, delete the oldest signals (e.g, the settings have changed)
        const store = await this.getStore('readwrite', db);
        await this.clearStoreIfNeeded(store);
        await this.countAndDeleteOldestIfNeeded(store, true);
        await store.transaction.done;
        return db;
    }
    async clearStoreIfNeeded(store) {
        // prevent the signals buffer from persisting across sessions (e.g, user closes tab and reopens)
        const sessionKey = 'segment_signals_db_session_key';
        if (!sessionStorage.getItem(sessionKey)) {
            this.sessionKeyStorage.setItem(sessionKey, true);
            await store.clear();
            logger_1.logger.debug('New Session, so signals buffer cleared');
        }
    }
    async add(signal) {
        const store = await this.getStore('readwrite');
        await store.add(signal);
        await this.countAndDeleteOldestIfNeeded(store);
        return store.transaction.done;
    }
    async countAndDeleteOldestIfNeeded(store, deleteMultiple = false) {
        let count = await store.count();
        if (count > this.maxBufferSize) {
            const cursor = await store.openCursor();
            if (cursor) {
                // delete up to maxItems
                if (deleteMultiple) {
                    while (count > this.maxBufferSize) {
                        await cursor.delete();
                        await cursor.continue();
                        count--;
                    }
                    logger_1.logger.debug(`Signals Buffer: Purged signals to max buffer size of ${this.maxBufferSize}`);
                }
                else {
                    // just delete the oldest item
                    await cursor.delete();
                    count--;
                }
            }
        }
    }
    /**
     * Get list of signals from the store, with the newest signals first.
     */
    async getAll() {
        const store = await this.getStore('readonly');
        const signals = await store.getAll();
        await store.transaction.done;
        return signals.reverse();
    }
    async clear() {
        const store = await this.getStore('readwrite');
        await store.clear();
        await store.transaction.done;
    }
}
exports.SignalStoreIndexDB = SignalStoreIndexDB;
SignalStoreIndexDB.DB_NAME = 'Segment Signals Buffer';
SignalStoreIndexDB.STORE_NAME = 'signals';
class SignalStoreSessionStorage {
    constructor(settings) {
        this.storageKey = 'segment_signals_buffer';
        this.maxBufferSize = settings.maxBufferSize ?? MAX_BUFFER_SIZE_DEFAULT;
    }
    add(signal) {
        const signals = this.getAll();
        signals.unshift(signal);
        if (signals.length > this.maxBufferSize) {
            // delete the last one
            signals.splice(-1);
        }
        sessionStorage.setItem(this.storageKey, JSON.stringify(signals));
    }
    clear() {
        sessionStorage.removeItem(this.storageKey);
    }
    getAll() {
        const signals = sessionStorage.getItem(this.storageKey);
        return signals ? JSON.parse(signals) : [];
    }
}
exports.SignalStoreSessionStorage = SignalStoreSessionStorage;
class SignalBuffer {
    constructor(store) {
        this.store = store;
    }
    async add(signal) {
        try {
            return await this.store.add(signal);
        }
        catch (e) {
            console.error(e);
            return undefined;
        }
    }
    async getAll() {
        try {
            return await this.store.getAll();
        }
        catch (e) {
            console.error(e);
            return [];
        }
    }
    async clear() {
        try {
            return await this.store.clear();
        }
        catch (e) {
            console.error(e);
            return undefined;
        }
    }
}
exports.SignalBuffer = SignalBuffer;
const getSignalBuffer = (settings) => {
    const store = settings.signalStorage ?? settings.storageType === 'session'
        ? new SignalStoreSessionStorage(settings)
        : new SignalStoreIndexDB(settings);
    return new SignalBuffer(store);
};
exports.getSignalBuffer = getSignalBuffer;
//# sourceMappingURL=index.js.map