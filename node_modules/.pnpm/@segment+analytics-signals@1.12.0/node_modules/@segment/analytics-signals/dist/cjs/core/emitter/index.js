"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalEmitter = void 0;
/**
 * Normalizes all subscribers to a single interface
 * Waits for the current plugin to load before emitting signals
 * @internal
 */
class SignalsSubscriberAdapter {
    constructor(subscriber) {
        this.subscriber = subscriber;
    }
    load(ctx) {
        if (typeof this.subscriber === 'function')
            return;
        this.loadedPromise = Promise.resolve(this.subscriber.load(ctx));
    }
    process(signal) {
        const sub = this.subscriber;
        if (typeof sub === 'function') {
            sub(signal);
        }
        else {
            if (this.loadedPromise) {
                void this.loadedPromise.then(() => sub.process(signal));
            }
            else {
                throw new Error('load() must be called before process()');
            }
        }
    }
}
class SignalEmitter {
    constructor(settings) {
        this.subscribers = new Set();
        this.middlewares = new Set();
        this.signalQueue = []; // Buffer for signals emitted before initialization
        if (settings?.middleware) {
            this.addMiddleware(...settings.middleware);
        }
    }
    /**
     * Load all middleware, flush the buffer, and enable eager processing
     */
    async start(signalsMiddlewareContext) {
        if (this.startedCtx)
            return this;
        //  Load all middleware, waiting for all of them to complete their load method before processing any singals
        await Promise.all([...this.middlewares].map((mw) => mw.load(signalsMiddlewareContext)));
        // Load all destinations/subscribers, but do not wait for their load methods to be invoked, since they are not supposed to modify signals.
        this.subscribers.forEach((sub) => {
            void sub.load(signalsMiddlewareContext);
        });
        // Enable eager processing of signals
        this.startedCtx = signalsMiddlewareContext;
        // Flush all buffered signals
        while (this.signalQueue.length > 0) {
            const signal = this.signalQueue.shift();
            this.processAndEmit(signal);
        }
        return this;
    }
    /**
     * Enqueue a signal to be processed by all plugins and subscribers
     */
    emit(signal) {
        if (!this.startedCtx) {
            // Buffer the signal if not initialized
            this.signalQueue.push(signal);
            return;
        }
        // Process and notify listeners
        this.processAndEmit(signal);
    }
    addMiddleware(...mws) {
        mws.forEach((mw) => {
            if (this.startedCtx) {
                void mw.load(this.startedCtx);
            }
            this.middlewares.add(mw);
        });
        return this;
    }
    removeMiddleware(...mws) {
        mws.forEach((mw) => this.middlewares.delete(mw));
        return this;
    }
    /**
     * Listen to signals emitted, once they have travelled through the plugin pipeline.
     * This is equivalent to a destination plugin.
     */
    subscribe(...subs) {
        subs
            .map((d) => new SignalsSubscriberAdapter(d))
            .forEach((d) => {
            if (!this.subscribers.has(d)) {
                if (this.startedCtx) {
                    void d.load(this.startedCtx);
                }
                this.subscribers.add(d);
            }
        });
        return this;
    }
    unsubscribe(...unsubbed) {
        unsubbed.forEach((toUnsubscribe) => {
            const adapter = [...this.subscribers].find((s) => s.subscriber === toUnsubscribe);
            if (adapter) {
                this.subscribers.delete(adapter);
            }
        });
        return this;
    }
    processAndEmit(signal) {
        // Apply plugin; drop the signal if any plugin returns null
        for (const middleware of this.middlewares) {
            const processed = middleware.process(signal);
            if (processed === null)
                return; // Drop the signal
        }
        // Process events for subscribers
        for (const subscriber of this.subscribers) {
            // Emit shallow copy as basic protection against accidental modification
            // Subscribers should not modify signals
            const signalCopy = { ...signal };
            subscriber.process(signalCopy);
        }
    }
}
exports.SignalEmitter = SignalEmitter;
//# sourceMappingURL=index.js.map