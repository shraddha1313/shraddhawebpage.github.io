import { parseDebugModeQueryString } from '../debug-mode';
import { logger } from '../../lib/logger';
import { WebStorage } from '../../lib/storage/web-storage';
import { MutationGeneratorSettings } from '../signal-generators/dom-gen/change-gen';
import { NetworkSettingsConfig } from '../middleware/network-signals-filter/network-signals-filter';
/**
 * Global settings for the application
 * In the future this pattern may allows us to add settings which can be dynamically set by the user.
 * Currently, this is just a way to pass settings to the different parts of the application.
 */
export class SignalGlobalSettings {
    constructor(settings) {
        this.sampleSuccess = false;
        if (settings.maxBufferSize && settings.signalStorage) {
            throw new Error('maxBufferSize and signalStorage cannot be defined at the same time');
        }
        this.mutationGenerator = new MutationGeneratorSettings({
            extraSelectors: settings.mutationGenExtraSelectors,
            observedRoles: settings.mutationGenObservedRoles,
            observedTags: settings.mutationGenObservedTags,
            pollIntervalMs: settings.mutationGenPollInterval,
            observedAttributes: settings.mutationGenObservedAttributes,
        });
        this.signalsDebug = new SignalsDebugSettings(settings.disableSignalsRedaction, settings.enableSignalsIngestion);
        this.signalBuffer = {
            signalStorage: settings.signalStorage,
            storageType: settings.signalStorageType,
            maxBufferSize: settings.maxBufferSize,
        };
        this.ingestClient = {
            apiHost: settings.apiHost,
            flushAt: settings.flushAt,
            flushInterval: settings.flushInterval,
            shouldDisableSignalsRedaction: this.signalsDebug.getDisableSignalsRedaction,
            shouldIngestSignals: () => {
                if (this.signalsDebug.getEnableSignalsIngestion()) {
                    return true;
                }
                if (this.sampleSuccess) {
                    return true;
                }
                return false;
            },
        };
        this.sandbox = {
            functionHost: settings.functionHost,
            processSignal: settings.processSignal,
            edgeFnDownloadURL: undefined,
        };
        this.network = new NetworkSettingsConfig({
            networkSignalsAllowList: settings.networkSignalsAllowList,
            networkSignalsDisallowList: settings.networkSignalsDisallowList,
            networkSignalsAllowSameDomain: settings.networkSignalsAllowSameDomain,
        });
    }
    update({ edgeFnDownloadURL, disallowListURLs, sampleRate, }) {
        edgeFnDownloadURL && (this.sandbox.edgeFnDownloadURL = edgeFnDownloadURL);
        this.network.networkSignalsFilterList.disallowed.addURLLike(...disallowListURLs.filter((val) => Boolean(val)));
        this.sampleSuccess = this.checkSampleRate(sampleRate ?? 0);
    }
    checkSampleRate(sampleRate) {
        const storage = new WebStorage(window.sessionStorage);
        const previousSample = storage.getItem('segment_sample_success');
        if (previousSample !== undefined) {
            return previousSample;
        }
        if (sampleRate && Math.random() <= sampleRate) {
            storage.setItem('segment_sample_success', true);
            return true;
        }
        storage.setItem('segment_sample_success', false);
        return false;
    }
}
export class SignalsDebugSettings {
    constructor(disableRedaction, enableIngestion) {
        this.storage = new WebStorage(window.sessionStorage);
        this.setAllDebugging = (boolean) => {
            this.storage.setItem(SignalsDebugSettings.redactionKey, boolean);
            this.storage.setItem(SignalsDebugSettings.ingestionKey, boolean);
        };
        this.getDisableSignalsRedaction = () => {
            return (this.storage.getItem(SignalsDebugSettings.redactionKey) ?? false);
        };
        this.getEnableSignalsIngestion = () => {
            return (this.storage.getItem(SignalsDebugSettings.ingestionKey) ?? false);
        };
        if (typeof disableRedaction === 'boolean') {
            this.storage.setItem(SignalsDebugSettings.redactionKey, disableRedaction);
        }
        if (typeof enableIngestion === 'boolean') {
            this.storage.setItem(SignalsDebugSettings.ingestionKey, enableIngestion);
        }
        const debugModeInQs = parseDebugModeQueryString();
        logger.debug('debugMode is set to true via query string');
        if (typeof debugModeInQs === 'boolean') {
            this.setAllDebugging(debugModeInQs);
        }
    }
}
SignalsDebugSettings.redactionKey = 'segment_signals_debug_redaction_disabled';
SignalsDebugSettings.ingestionKey = 'segment_signals_debug_ingestion_enabled';
//# sourceMappingURL=settings.js.map