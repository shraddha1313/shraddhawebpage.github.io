import { isSameDomain } from '../../signal-generators/network-gen/helpers';
export class NetworkSettingsConfig {
    constructor({ networkSignalsAllowList, networkSignalsDisallowList, networkSignalsAllowSameDomain, }) {
        this.networkSignalsAllowSameDomain = networkSignalsAllowSameDomain ?? true;
        this.networkSignalsFilterList = new NetworkSignalsFilterList(networkSignalsAllowList, networkSignalsDisallowList);
    }
}
class NetworkFilterListItem {
    get combinedRegex() {
        const normalizeRegex = (regex) => {
            return typeof regex === 'string' ? new RegExp(regex) : regex;
        };
        return new RegExp(this.regexes
            .map((val) => normalizeRegex(val))
            .map((r) => r.source)
            .join('|'));
    }
    constructor(regexes) {
        this.regexes = regexes;
    }
    test(value) {
        if (!this.regexes.length) {
            return false;
        }
        return this.combinedRegex.test(value);
    }
    add(...regex) {
        this.regexes.push(...regex);
    }
    addURLLike(...urlLike) {
        const parsedRegexes = urlLike
            .map((domain) => this.urlToRegex(domain))
            .filter((val) => Boolean(val));
        this.add(...parsedRegexes);
    }
    urlToRegex(urlLike) {
        const clean = urlLike.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        try {
            return new RegExp(clean);
        }
        catch (e) {
            console.error(`Invalid regex: ${clean}`, e);
        }
    }
}
export class NetworkSignalsFilterList {
    constructor(allowList, disallowList) {
        this.allowed = new NetworkFilterListItem(allowList || []);
        this.disallowed = new NetworkFilterListItem(disallowList || []);
        this.disallowedDefaults = new NetworkFilterListItem([
            'api.segment.io',
            'signals.segment.io',
            'cdn.segment.com',
        ]);
    }
    isDisallowed(url) {
        return this.disallowed.test(url) || this.disallowedDefaults.test(url);
    }
    isAllowed(url) {
        return this.allowed.test(url);
    }
    getRegexes() {
        return {
            allowed: this.allowed.regexes.map((el) => el.toString()),
            disallowed: this.disallowed.regexes.map((el) => el.toString()),
        };
    }
}
export class NetworkSignalsFilter {
    constructor(settings) {
        this.settings = settings;
    }
    isAllowed(url) {
        const { networkSignalsFilterList, networkSignalsAllowSameDomain } = this.settings;
        // anything that is disallowed takes precedence over the allow list.
        if (networkSignalsFilterList.isDisallowed(url)) {
            return false;
        }
        const allowed = 
        // allowed because it's in the allow list
        networkSignalsFilterList.isAllowed(url) ||
            // allowed because it's the same domain
            (networkSignalsAllowSameDomain && isSameDomain(url));
        return allowed;
    }
}
export class NetworkSignalsFilterMiddleware {
    constructor() {
        this.createMetadata = () => ({
            filters: this.filter.settings.networkSignalsFilterList.getRegexes(),
        });
    }
    load(ctx) {
        this.filter = new NetworkSignalsFilter(ctx.unstableGlobalSettings.network);
    }
    process(signal) {
        if (signal.type === 'network') {
            signal.metadata = this.createMetadata();
            return this.filter.isAllowed(signal.data.url) ? signal : null;
        }
        else {
            return signal;
        }
    }
}
//# sourceMappingURL=network-signals-filter.js.map