import { cleanText } from './helpers';
const parseFormData = (data) => {
    return [...data].reduce((acc, [key, value]) => {
        if (typeof value === 'string') {
            acc[key] = value;
        }
        return acc;
    }, {});
};
const parseLabels = (labels) => {
    if (!labels)
        return [];
    return [...labels].map(parseToLabel).filter((el) => Boolean(el));
};
const parseToLabel = (label) => {
    const textContent = label.textContent ? cleanText(label.textContent) : '';
    return {
        id: label.id,
        attributes: parseNodeMap(label.attributes),
        textContent,
    };
};
const parseNodeMap = (nodeMap) => {
    return Array.from(nodeMap).reduce((acc, attr) => {
        if (typeof attr.value === 'string' || attr.value === null) {
            acc[attr.name] = attr.value;
        }
        return acc;
    }, {});
};
const getReferencedElement = (el, attr) => {
    const value = el.getAttribute(attr);
    if (!value)
        return undefined;
    return document.getElementById(value) ?? undefined;
};
export const parseElement = (el) => {
    const labels = parseLabels(el.labels);
    const labeledBy = getReferencedElement(el, 'aria-labelledby');
    const describedBy = getReferencedElement(el, 'aria-describedby');
    if (labeledBy) {
        const label = parseToLabel(labeledBy);
        labels.unshift(label);
    }
    const parsedAttributes = parseNodeMap(el.attributes);
    // This exists because of a bug in react-hook-form, where 'name', if used as the field registration name overrides the native element name value to reference itself.
    // This is a very weird scenario where a property was on the element, but not in the attributes map.
    // This probably only needs to be run on name, but running this on some other fields out of caution.
    const getSanitizedProp = (prop) => {
        if (!(prop in el)) {
            return undefined;
        }
        // @ts-ignore
        const val = el[prop];
        return typeof val === 'string' ? val : undefined;
    };
    const base = {
        attributes: parsedAttributes,
        classList: [...el.classList],
        id: getSanitizedProp('id') || '',
        labels,
        label: labels[0],
        name: getSanitizedProp('name'),
        nodeName: el.nodeName,
        tagName: el.tagName,
        title: getSanitizedProp('title') || '',
        type: getSanitizedProp('type'),
        value: getSanitizedProp('value'),
        textContent: (el.textContent && cleanText(el.textContent)) ?? undefined,
        innerText: (el.innerText && cleanText(el.innerText)) ?? undefined,
        describedBy: (describedBy && parseToLabel(describedBy)) ?? undefined,
    };
    if (el instanceof HTMLSelectElement) {
        return {
            ...base,
            selectedOptions: [...el.selectedOptions].map((option) => ({
                value: option.value,
                label: option.label,
            })),
            selectedIndex: el.selectedIndex,
        };
    }
    else if (el instanceof HTMLInputElement) {
        return {
            ...base,
            checked: el.checked,
        };
    }
    else if (el instanceof HTMLMediaElement) {
        return {
            ...base,
            currentSrc: el.currentSrc,
            currentTime: el.currentTime,
            duration: el.duration,
            ended: el.ended,
            muted: el.muted,
            paused: el.paused,
            playbackRate: el.playbackRate,
            readyState: el.readyState,
            src: el.src,
            volume: el.volume,
        };
    }
    else if (el instanceof HTMLFormElement) {
        return {
            ...base,
            innerText: undefined,
            textContent: undefined,
            formData: parseFormData(new FormData(el)),
        };
    }
    return base;
};
//# sourceMappingURL=element-parser.js.map