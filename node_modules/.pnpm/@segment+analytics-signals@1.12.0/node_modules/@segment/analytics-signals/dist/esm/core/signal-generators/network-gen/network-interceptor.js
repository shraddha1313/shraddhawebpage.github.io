import { createRequestId, isOk, normalizeHeaders, normalizeRequestInfo, tryJSONParse, } from './helpers';
let origFetch;
let origXMLHttpRequest;
const toHTTPMethod = (method) => {
    return method.toUpperCase();
};
const createInterceptorRequest = ({ url, body, headers, id, method, }) => ({
    url: url.toString(),
    method: method,
    headers: headers ?? new Headers(),
    contentType: headers?.get('content-type') ?? undefined,
    body: typeof body == 'string' ? body : undefined,
    id,
});
const createInterceptorResponse = ({ body, headers, initiator, status, statusText, url, responseType, id, }) => ({
    body,
    headers,
    initiator,
    ok: isOk(status),
    status,
    statusText,
    url,
    responseType,
    req: {
        id: id,
    },
});
/**
 * NetworkInterceptor class to intercept network requests and responses
 */
export class NetworkInterceptor {
    addInterceptors(onRequest, onResponse) {
        this.addFetchInterceptor(onRequest, onResponse);
        this.addXhrInterceptor(onRequest, onResponse);
    }
    addFetchInterceptor(onRequest, onResponse) {
        if (!window.fetch) {
            return;
        }
        origFetch = window.fetch;
        window.fetch = async (...args) => {
            const [url, options] = args;
            const id = createRequestId();
            try {
                const normalizedURL = normalizeRequestInfo(url);
                const headers = options?.headers
                    ? normalizeHeaders(options.headers)
                    : undefined;
                onRequest(createInterceptorRequest({
                    url: normalizedURL,
                    body: typeof options?.body == 'string' ? options.body : undefined,
                    method: options?.method ? toHTTPMethod(options.method) : 'GET',
                    headers,
                    id,
                }));
            }
            catch (err) {
                console.log('Error handling request: ', err);
            }
            const ogResponse = await origFetch(...args);
            // response.text() etc is single use only -- to prevent conflicts with app code, use clone
            // https://developer.mozilla.org/en-US/docs/Web/API/Response/clone
            const response = ogResponse.clone();
            try {
                const lazyBody = async () => {
                    let text;
                    try {
                        text = await response.text();
                    }
                    catch (err) {
                        console.warn('Error converting to text', err, response);
                        return null;
                    }
                    return tryJSONParse(text); // should never throw.
                };
                onResponse(createInterceptorResponse({
                    body: lazyBody,
                    headers: response.headers,
                    initiator: 'fetch',
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url,
                    responseType: undefined,
                    id: id,
                }));
            }
            catch (err) {
                console.log('Error handling response: ', err);
            }
            return ogResponse;
        };
    }
    addXhrInterceptor(onRequest, onResponse) {
        if (!window.XMLHttpRequest) {
            return;
        }
        const OrigXMLHttpRequest = window.XMLHttpRequest;
        class InterceptedXMLHttpRequest extends OrigXMLHttpRequest {
            getParsedXHRHeaders(allResponseHeaders) {
                const headers = new Headers();
                allResponseHeaders
                    .trim()
                    .split(/[\r\n]+/)
                    .forEach((line) => {
                    const parts = line.split(': ');
                    const header = parts.shift();
                    const value = parts.join(': ');
                    if (header) {
                        headers.append(header, value);
                    }
                });
                return headers;
            }
            getParsedXHRBody() {
                if (this.responseType === 'json') {
                    return this.response;
                }
                else if (typeof this.response === 'string') {
                    return tryJSONParse(this.response);
                }
                return null;
            }
            constructor() {
                super();
                this._reqId = createRequestId();
                this.addEventListener('readystatechange', () => {
                    // Handle request
                    if (this.readyState === this.HEADERS_RECEIVED) {
                        try {
                            onRequest(createInterceptorRequest({
                                url: this._reqURL,
                                method: this._reqMethod,
                                headers: this._reqHeaders,
                                id: this._reqId,
                                body: this._reqBody ? this._reqBody.toString() : undefined,
                            }));
                        }
                        catch (err) {
                            console.log('Error handling request', err);
                        }
                    }
                    // Handle response
                    if (this.readyState === this.DONE) {
                        try {
                            onResponse(createInterceptorResponse({
                                status: this.status,
                                responseType: this.responseType,
                                statusText: this.statusText,
                                url: this.responseURL,
                                initiator: 'xhr',
                                body: () => Promise.resolve(this.getParsedXHRBody()),
                                headers: this.getParsedXHRHeaders(this.getAllResponseHeaders()),
                                id: this._reqId,
                            }));
                        }
                        catch (err) {
                            console.log('Error handling response', err);
                        }
                    }
                });
            }
            // @ts-ignore
            open(...args) {
                const [method, url] = args;
                try {
                    this._reqURL = url.toString();
                    this._reqMethod = toHTTPMethod(method);
                }
                catch (err) {
                    console.log('Error handling request (open)', err);
                }
                super.open(...args);
            }
            send(body) {
                this._reqBody = body;
                super.send(body);
            }
            setRequestHeader(...args) {
                try {
                    const [header, value] = args;
                    if (!this._reqHeaders) {
                        this._reqHeaders = new Headers();
                    }
                    this._reqHeaders.append(header, value);
                }
                catch (err) {
                    console.log('Error handling request (setRequestHeader)', err);
                }
                super.setRequestHeader(...args);
            }
        }
        ;
        window.XMLHttpRequest = InterceptedXMLHttpRequest;
    }
    cleanup() {
        origXMLHttpRequest && (window.XMLHttpRequest = origXMLHttpRequest);
        origFetch && (window.fetch = origFetch);
    }
}
//# sourceMappingURL=network-interceptor.js.map